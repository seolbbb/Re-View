
#### Step 1: 슬라이드 경계 감지

# 예시: 6분 영상에서 3개 슬라이드  
슬라이드 1: [0초 ~ 120초]  
슬라이드 2: [120초 ~ 240초]  ← 현재 캡처 대상  
슬라이드 3: [240초 ~ 360초]

**감지 방법**:
- 장면 전환 시점(t=120초, t=240초)을 기록
- 이전 전환 시점 ~ 현재 전환 시점 = 현재 슬라이드 구간
#### Step 2: 무작위 프레임 수집

# 슬라이드 2 구간 [120초 ~ 240초]에서 50개 프레임 랜덤 샘플링  
random_times = [125초, 133초, 147초, ..., 235초]  # 총 50개  
  
for t in random_times:  
    cap.set(cv2.CAP_PROP_POS_MSEC, t * 1000)  
    ret, frame = cap.read()  
    frames.append(frame)

#### Step 3: Temporal Median

median_frame = np.median(frames, axis=0)

### ✅ 장점

1. **슬라이드 순수성 100%**
    
    - 같은 슬라이드 내에서만 수집 → 다른 슬라이드 내용 혼합 불가능
2. **마우스 제거 확률 극대화**
    
    슬라이드 2 (120초) 동안 마우스 위치:  
    - 125초: (100, 200)  
    - 133초: (150, 250)  
    - 147초: (200, 300)  
    ...  
    → 각 픽셀에서 마우스가 없는 프레임이 대부분
    
3. **정적 마우스 완벽 대응**
    
    - 마우스가 한 곳에 10초 고정되어도, 120초 중 10초 = 8.3%만 해당 위치
    - Median 계산 시 무시됨

### ⚠️ 단점 & 해결책

**단점 1: 슬라이드 경계 감지 필요**

python

# 현재는 장면 전환만 감지  
# 추가 필요: 전환 시점을 저장하여 슬라이드 구간 추적

**해결책**:

python

slide_boundaries = []  # [(0, 120), (120, 240), (240, 360)]  
  
# extract_keyframes에서 장면 전환 감지 시:  
if mean_diff > threshold:  
    slide_boundaries.append((last_change_time, current_time))

**단점 2: 구현 복잡도**

- 기존 코드 구조 변경 필요